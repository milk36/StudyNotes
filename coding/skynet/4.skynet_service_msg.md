skynet服务间消息通讯
---
## 本地服务间消息通讯
### 消息类型
* `skynet.h` 中定义的消息类型
    ```c
    #define PTYPE_TEXT 0   
    #define PTYPE_RESPONSE 1    //表示一个回应包
    #define PTYPE_MULTICAST 2   //广播消息
    #define PTYPE_CLIENT 3      //用来处理网络客户端的请求消息
    #define PTYPE_SYSTEM 4      //系统消息
    #define PTYPE_HARBOR 5      //跨节点消息
    #define PTYPE_SOCKET 6    //套接字消息
    #define PTYPE_ERROR 7     //错误消息，一般服务退出的时候会发送error消息给关联的服务
    #define PTYPE_QUEUE 8
    #define PTYPE_DEBUG 9
    #define PTYPE_LUA 10   //lua类型的消息，最常用
    #define PTYPE_SNAX 11  //snax服务消息
    ​
    #define PTYPE_TAG_DONTCOPY 0x10000
    #define PTYPE_TAG_ALLOCSESSION 0x20000
    ```
### 打包与解包消息
* `skynet.pack(...)` 打包操作

    返回两个参数: msg 是一个C指针指向数据包的起始地址

    sz是数据包的长度
* `skynet.unpack(msg,sz)` 根据`msg消息指针`和`sz消息长度`解包消息
* `skynet.trash(msg,sz)` 释放消息指针
* `18-testpack.lua` 代码
    ```lua
    local skynet = require "skynet"

    skynet.start(function()
        local msg, sz = skynet.pack("testmsg",1.22,false) --打包消息,返回msg指针和sz消息长度
        local arg1,arg2,arg3 = skynet.unpack(msg,sz) --通过 msg和sz 解包消息
        skynet.error(arg1,arg2,arg3)

        local arglist = {skynet.unpack(msg,sz)}
        for i,v in pairs(arglist) do
            skynet.error("arg"..i..":",v)
        end

        skynet.trash(msg,sz) --释放消息指针
    end)
    ```
## 发送消息
### 接收(监听)消息
* `skynet.dispatch` 注册监听消息服务
    ```lua
    --服务启动入口
    skynet.start(function()
        --注册"lua"类型消息的回调函数
        skynet.dispatch("lua", function(session, address, ...)
            dosomething(...)
        end)
    end)
    ```
* `19-testluamsg.lua`
    ```lua
    local skynet = require "skynet"
    require "skynet.manager"

    local function handlermsg(session,address,...)
        skynet.error("co",coroutine.running())
        skynet.error("session",session)
        skynet.error("address",address)
        local args = {...}
        for i,v in pairs(args) do
            skynet.error("arg"..i..":",v)
        end
    end

    skynet.start(function()
        skynet.dispatch("lua",function(session,address,...)
            handlermsg(session,address,...)
        end) --监听lua类型消息

        skynet.register(".testluamsg") --注册当前服务定一个别名

        skynet.error("co",coroutine.running())
    end)
    ```
### 发送消息
* 两种发送方式 `send` 和 `rawsend`
    ```lua
    --用 type 类型向 addr 发送未打包的消息。该函数会自动把...参数列表进行打包，默认情况下lua消息使用skynet.pack打包。addr可以是服务句柄也可以是别名。
    skynet.send(addr, type, ...)
    ​
    --用 type 类型向 addr 发送一个打包好的消息。addr可以是服务句柄也可以是别名。
    skynet.rawsend(addr, type, msg, sz) 
    ```
* `20-testsendmsg.lua`
    ```lua
    local skynet = require "skynet"
    require "skynet.manager"

    skynet.start(function()
        skynet.register(".testsendmsg") --注册当前服务定一个别名
        local testluamsg = skynet.localname(".testluamsg") --获取本地服务

        --skynet.send内部调用了skynet.pack
        local r = skynet.send(testluamsg,"lua",99,"testmsg99",true)
        skynet.error("skynet.send return value:",r)

        --使用skynet.pack手动打包数据
        r = skynet.rawsend(testluamsg,"lua",skynet.pack(100,"testmsg100",false))
        skynet.error("skynet.rawsend return value:",r)
        --skynet会等到该消息处理完后，自动释放掉它的内存, 所以不用手动调用 skynet.trash(msg,sz) 释放
    end)
    ```
* 输出:
    ```sh
    19-testluamsg
    [:01000010] LAUNCH snlua 19-testluamsg #启动接收消息监听服务 .testluamsg
    [:01000010] co thread: 0x7fb4f560a1c8 false #协程id
    20-testsendmsg
    [:01000012] LAUNCH snlua 20-testsendmsg #启动消息发送服务 .testsendmsg
    [:01000012] skynet.send return value: 0 #打印发送返回值
    [:01000012] skynet.rawsend return value: 0 #打印发送返回值
    [:01000010] co thread: 0x7fb4f560a1c8 false #协程id
    #19-testluamsg服务 接收到消息
    [:01000010] session 0 #session id
    [:01000010] address 16777234 #地址信息
    [:01000010] arg1: 99 #消息内容
    [:01000010] arg2: testmsg99 #消息内容
    [:01000010] arg3: true #消息内容
    [:01000010] co thread: 0x7fb4f560a1c8 false
    [:01000010] session 0 #session id
    [:01000010] address 16777234 #地址信息
    [:01000010] arg1: 100 #消息内容
    [:01000010] arg2: testmsg100 #消息内容
    [:01000010] arg3: false #消息内容
    ```
## 必须响应的消息
### 发送必须响应的消息
> session只有在使用skynet.call或者skynet.rawcall发送消息的时候才有意义。
* `skynet.call` 和 `skynet.rawcall` 发送消息
    ```lua
    --用默认函数打包消息，向addr发送type类型的消息并等待返回响应，并对回应信息进行解包。（自动打包与解包。）
    skynet.call(addr, type, ...) 
    --直接向addr发送type类型的msg,sz并等待返回响应，不对回应信息解包。（需要自己打包与解包）
    skynet.rawcall(addr, type, msg, sz) 
    ```
* `skynet.ret` 和 `skynet.retpack` 响应/返回消息
    ```lua
    skynet.ret --目标服务消息处理后需要通过该函数将结果返回
    skynet.retpack(...) --将消息用skynet.pack 打包，并调用 ret 回应。
    ```
* 修改`19-testluamsg.lua` 接收消息代码
    ```lua
    local skynet = require "skynet"
    require "skynet.manager"

    local function handlermsg(session,address,...)
        skynet.error("co",coroutine.running())
        skynet.error("session",session)
        skynet.error("address",address)
        local args = {...}
        for i,v in pairs(args) do
            skynet.error("arg"..i..":",v)
        end
        return "ret call msg"
    end

    skynet.start(function()
        skynet.dispatch("lua",function(session,address,...)
            skynet.sleep(100) --接收到消息后 延迟一秒后返回数据
            -- skynet.ret(skynet.pack(handlermsg(session,address,...)))
            skynet.retpack(handlermsg(session,address,...)) --skynet.retpack内封装了pack操作
        end) --监听lua类型消息

        skynet.register(".testluamsg") --注册当前服务定一个别名

        skynet.error("co",coroutine.running())
    end)
    ```
* `21-testcallmsg.lua`发送消息代码
    ```lua
    local skynet = require "skynet"
    require "skynet.manager"

    skynet.start(function()
        skynet.register(".testcallmsg") --注册当前服务别名
        --该函数将阻塞等待响应返回
        local r = skynet.call(".testluamsg","lua",101,"testcallmsg",false) --skynet.call 发送消息并等待返回值
        skynet.error("skynet.call return value:",r)

        --该函数将阻塞等待响应返回
        r = skynet.unpack(skynet.rawcall(".testluamsg","lua",skynet.pack(102,"testrawcallmsg",true))) --skynet.rawcall 发送消息并等待返回值
        skynet.error("skynet.rawcall return value:",r)
    end)
    ```
* 输出:
    ```sh
    19-testluamsg
    [:01000010] LAUNCH snlua 19-testluamsg
    [:01000010] co thread: 0x7f0edf44e008 false
    21-testcallmsg
    [:01000012] LAUNCH snlua 21-testcallmsg
    #19-testluamsg服务 接收到消息
    [:01000010] co thread: 0x7f0edf44e008 false
    [:01000010] session 2 #session只有在使用skynet.call或者skynet.rawcall发送消息的时候才有意义。
    [:01000010] address 16777234
    [:01000010] arg1: 101
    [:01000010] arg2: testcallmsg
    [:01000010] arg3: false
    [:01000012] skynet.call return value: ret call msg #21-testcallmsg服务 阻塞等待响应返回值
    #19-testluamsg服务 接收到消息
    [:01000010] co thread: 0x7f0edf44e008 false
    [:01000010] session 3 #session只有在使用skynet.call或者skynet.rawcall发送消息的时候才有意义。
    [:01000010] address 16777234
    [:01000010] arg1: 102
    [:01000010] arg2: testrawcallmsg
    [:01000010] arg3: true
    [:01000012] skynet.rawcall return value: ret call msg #21-testcallmsg服务 阻塞等待响应返回值
    ```
## lua发送消息综合应用
###  接收处理指令
* `22-mydb.lua`
    ```lua
    local skynet = require "skynet"
    require "skynet.manager"

    local db={}
    local command = {}

    function command.GET(key)
        return db[key]
    end

    function command.SET(key,value)
        db[key] = value
    end

    skynet.start(function()
        skynet.dispatch("lua",function(session,address,cmd,...)
            key = cmd:upper() --字符串转大写
            skynet.error("cmd",key," :param",...)
            local f = command[key] --获取对应指令函数
            if f then
                skynet.retpack(f(...)) --调用指令并返回
            else
                skynet.retpack("cmd error") --返回指令错误
                skynet.error(string.format("unknown command %s",tostring(key)))
            end
        end)

        skynet.register ".mydb"
    end)
    ```
###  发送指令消息
* `23-testmydb.lua`
    ```lua
    local skynet = require "skynet"

    local key,value = ... --服务启动参数

    function task()
        skynet.error("key",key,":value",value)
        local r = skynet.send(".mydb","lua","set",key,value) --调用mydb服务set 参数为 key value
        skynet.error("mydb set ret",r)

        local mydb = skynet.localname(".mydb")
        r = skynet.call(mydb,"lua","get",key) --调用mydb服务get 参数为 key
        skynet.error("mydb get ret",r)
        skynet.exit()
    end

    skynet.start(function()
        skynet.fork(task)
    end)
    ```
### 输出
* 控制台输出:
    ```sh
    22-mydb
    [:01000010] LAUNCH snlua 22-mydb
    23-testmydb poweroff 99 #启动测试服务 及参数
    [:01000012] LAUNCH snlua 23-testmydb poweroff 99
    [:01000012] key poweroff :value 99
    [:01000012] mydb set ret 0
    [:01000010] cmd SET  :param poweroff 99
    [:01000010] cmd GET  :param poweroff
    [:01000012] mydb get ret 99
    [:01000012] KILL self
    ```
