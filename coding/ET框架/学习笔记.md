# ET学习笔记

单线程, 多进程
## 异常问题

### HttpListener拒绝访问异常

* 启动提示: `请现在cmd中运行: netsh http add urlacl url=http://*:你的address中的端口/ user=Everyone, address: http://+:30300/`

* [C#Http服务器报HttpListener拒绝访问异常解决方法](https://et-framework.cn/d/1062-netsh-http-add-urlacl-urlhttpaddress-usereveryone)
* 解决方式:

  ```cmd
  netsh http add urlacl url=http://+:30300/ user=Everyone
  ```

### StreamingAssets

* 打包提示:Unity\Assets目录下缺一个目录StreamingAssets
* 解决方式: [手工添加目录StreamingAssets](https://et-framework.cn/d/593-unityassetsstreamingassets)

### il2cpp is not installed

* 打包提示 `il2cpp` 没有安装: Unity 错误:currently selected scripting backend(il2cpp) is not installed
* 解决方式: 在安装器中添加`il2cpp`模块 [参考CSDN](https://blog.csdn.net/qq_39342142/article/details/100661184)
  
  <img src="./img/ET6_build_1.png" width="50%"/>

## 框架概念

### 工程目录结构 (ET6)

* Client 目录下:

  ```js
  Unity.Hotfix     //逻辑层, 可热更代码, 主要存放system操作的定义
  Unity.HotfixView //显示层,有调用Unity相关API
  Unity.Model      //逻辑层, 主要存放 entity和component类型的定义
  Unity.ModelView  //显示层
  ```

  区分了逻辑层与显示层代码,以便于服务端和机器人的代码公用

  显示层可以引用逻辑层代码, 但逻辑层无法引用显示层代码, 逻辑层->显示层 *只能通过事件做交互*

### ECS

* **E就是Entity，C就是Component，S是System**
* ECS最重要的设计是 **逻辑** 跟 **数据** 的完全分离。即EC(Entity与Component)是纯数据，System实际上就是逻辑，由数据驱动逻辑。
* Entity :实体是指存在游戏世界中的一个独特物体,是一系列组件的集合
* Component: 组件是一堆数据的集合,组件没有方法,即不存在任何的行为,只用来存储状态
* System: 系统就是对拥有一个或者多个 相同组件的实体集合进行 **操作的工具**,它只有行为,没有状态,即不存在任何数据
* ET框架中的ECS编程原则
  1. 实体即组件,组件即实体
  2. 编写一个新的实体或者组件,绝不继承除Entity之外的任何父类
  3. 绝不使用任何的虚函数,使用逻辑分发替代
  4. Model和ModelView只存放实体和组件的数据字段声明,非必要绝不放任何逻辑函数
  5. Hotfix和HotfixView中只保留纯逻辑函数,也就是使用静态类和扩展方法编写的System,且绝不允许存在任何数据字段
  6. Model和Hotfix中绝不允许出现跟Unity3D引擎相关的游戏对象类和相关API函数调用
  7. 如实体或组件有数据字段声明,**必须编写相关生命周期函数**,以防实体对象池回收再利用导致逻辑错误.

### 组件式设计

* 组件模式的特点:
  1. 高度模块化, 一个组件就是一份数据 + 一段逻辑
  1. 组件可热插拔, 需要就加上, 不需要就删除  
  1. 类型之间依赖极少, 任何类型增加或删除组件不会影响到其他类型

### Scene层级说明

* Scene 概念
  
  <img src="./img/ET_Scene_0.png" width="50%" />
* 客户端

  <img src="./img/ET_Scene_Client_1.png" width="50%" />
* 服务端
  
  <img src="./img/ET_Scene_Server_1.png" width="50%" />
* 机器人

  <img src="./img/ET_Scene_Robot_1.png" width="50%" />

  RobotZoneScene等同于客户端中的ZoneScene, 即代表一个玩家
* Scene相关代码
  1. `Unity/Codes/Model/Core/Entity/SceneType.cs` 类型
  1. `Server/Server.Hotfix/Demo/Scene/SceneFactory.cs` 服务端scene工厂
* Scene相关配置
  
  `StartSceneConfig@s.xlsx`
* 代码中获取Scene

   ```c#
   //var domain = self.Domain(); //不推荐直接调用Domain()
   //推荐使用下面两种方式获取 currentScene
   self.ZoneScene();
   self.DomainScene();
   ```

### ET异步操作

* 同步操作, 即常见的线性的执行代码逻辑
* 异步操作, 即大部分逻辑是在调用之后才完成的 适用场景: IO操作, CPU密集型操作
* ETTask的存在主要是为了抹除回调,增加代码可读性

### EventSystem 事件机制

### Actor

* ET采用的是:单线程,多进程的架构
* ET中，Actor是Entity对象，**Entity挂上一个`MailboxComponent`组件就是一个Actor了**
* 处理Send的消息, 需要继承`AMActorHandler`抽象类
* 处理Rpc消息, 需要继承`AMActorRpcHandler`抽象类

### Actor Location

* 用于跨进程访问/调用Actor

### Demo 项目包含模块

服务器类型:

  1. Realm 负载均衡
  1. Gate
  1. Map 场景
  1. Location 定位Actor所在进程

### ET6 Demo启动入口

* 客户端
  
  `Client/Unity.HotfixView/Codes/HotfixView/Demo/UI/UILogin/AppStartInitFinish_CreateLoginUI.cs`
* 服务端
  
  `Server/Server.Hotfix/AppStart_Init.cs`

  启动可选项: `Robot\Robot.Model\Core\Options.cs`
  * `--Develop` : 0正式 1开发 2压测
  * `--LogLevel` : 日志级别
  * `--Console` : 控制台

### 备忘代码块

* ET框架内的 wait 调用方式
  
  `await TimeComponent.Instance.WaitAsync(3000); //等待3秒`

## 相关工具

### Excel 导出工具

1. 执行配置导出程序脚本: `ET\Excel\win_startExcelExport.bat`
1. 在工程内启动导表工具的方式:

   Tools.APP 启动项中添加参数:`--AppType=ExcelExporter`

   <img src="./img/ET_Excel_1.png" width="50%"/>
1. `Tools/App/Apps/ExcelExporter/ExcelExporter.cs` 导出工具代码
1. 生成配置类型文件目录:

   客户端:`ET/Unity/Codes/Model/Generate/Config`

   服务端:`ET/Server/Model/Generate/Config/`
1. ET配置表导出工具执行前,务必先执行工程build操作
1. 导出规则:配置表头带 `#` 表示不用导出的字段, `c` 表示只导出到客户端, `s` 表示只导出到服务端
   * 第二行,控制整列数据导出规则  
   * 第二列,控制整行数据导出规则
   * 如果在表第一行,第一列填写,则控制整个配置表导出规则
  
     <img src="./img/ET_Config_3.png" width="50%"/>

   * 可以添加空行以便配置数据的分类, 示例如下:

     <img src="./img/ET_Config_4.png" width="50%"/>

   * 如果配置表中有多个表单, 也可以在表单名加相关前缀:

     <img src="./img/ET_Config_5.png" width="20%"/>

1. Excel配置生成文件对应目录:

     1. `ET\Excel\Json` //人工可读txt文件分别在 c, s 目录
  
     1. `ET\Unity\Assets\Bundles\Config` //生成bytebuff文件目录
  
     1. `ET\Unity\Codes\Model\Generate\Config` //客户端生成映射对象结构
  
     1. `ET\Server\Model\Generate\Config` //服务端生成的对象结构

1. 调用代码

   配置文件会生成对应的 `XXXConfig` 和 `XXXCategory` 代码, `XXXCategory` 可以理解成对应配置类型的管理容器

   对应生成的代码模板文件:`Tools/App/Template.txt`

   ```c#
   UnitConfig config = UnitConfigCategory.Instance.Get(1001); //使用Id获取Unit类型配置
   Log.Debug(config.Name);
   var allUnitConfigs = UnitConfigCategory.Instance.GetAll(); //获取所有Unit类型配置
   foreach (var unitConfig in allUnitConfigs.Values)
   {
    Log.Debug(unitConfig.Name);
   }
   ```

1. 扩展配置类型

   `Config` 和 `Category` 都是使用 `partial`(分部类型),也就是说可以支持逻辑的拆分扩展, 示例:

   ```c#
   public partial class UnitConfig
   {
    //扩展Config
     public string _Name()
     {
       return "UnitConfig:" + this.Name;
     }
   }
   public partial class UnitConfigCategory
   {
     //扩展Category
     public UnitConfig GetUnitConfigByHeight(int height)
     {
       UnitConfig unitConfig = null;
       foreach (var info in this.dict.Values)
       {
         if(info.Height == height)
         {
           unitConfig = info;
           break;
         }
       }
       return unitConfig;
     }
   }
   ```

1. 已支持的配置类型参考: `Tools/Tools.App/Apps/ExcelExporter/ExcelExporter.Convert` 函数

### Protobuf导出工具

1. 执行配置导出程序脚本: `ET\Proto\win_startProtoExport.bat`
1. 在工程内启动导表工具的方式:

   Tools.APP 启动项中添加参数:`--AppType=Proto2CS`

   <img src="./img/ET_Protobuf_1.png" width="50%"/>
1. `Tools\Tools.App\Apps\Proto2CS\Proto2CS.cs` 导出工具代码
1. 生成协议类文件目录:

   客户端:`ET/Unity/Codes/Model/Generate/Message/`

   服务端:`ET/Server/Model/Generate/Message/`

   1. `OuterOpcode.cs` 协议码
   1. `OuterMessage.cs` 协议类型



## 其他

### 论坛资料

* [ETTask](https://et-framework.cn/d/46-ettask)
* [ET中的Actor机制](https://et-framework.cn/d/47-actor)
* [服务器命名以及消息类的端到端的命名方式](https://et-framework.cn/d/51)