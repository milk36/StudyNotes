<!-- markdownlint-disable MD033 -->
# 网络游戏架构设计 笔记六

## 机器人与单元测试

* 机器人的作用
  1. 功能开发辅助
  1. 单元测试
  1. 性能压测
  1. 逻辑压测(针对每个系统的压测)
  1. 模拟真实玩家(匹配机器人)

服务端引用客户端代码实现机器人逻辑, 客户端引用服务端代码在 unity 跑服务器逻辑(Client Server)

### 命名空间

三个命名空间: `ET.Client` `ET.Server`, `ET` (针对Share目录前后端共享代码)

### Define.cs 全局宏管理

`Hotfix` 逻辑层没有宏处理, 通过 `Define.cs` 控制全局变量来实现同样的功能

### 工程目录结构

逻辑代码根目录:`Unity\Assets\Scripts\Codes`

* DotNet 服务端
  
  1. App 启动模块
  1. Core 核心代码
  1. Hotfix 逻辑层
  1. Model 数据层
  1. Loader 加载Dll,与初始化
  1. ThirdParty 第三方包 如: protobuf-net , Mongodb, NLog, kcp, Recast 等
* Share
  
  1. ExcelExporter 配置导表工具
  1. Proto2CS 协议生成工具
* Unity 客户端

  1. Core 核心代码
  1. Hotfix 逻辑层
  1. HotfixView 显示层逻辑层
  1. Model 数据层
  1. ModelView 显示层数据层
  1. Loader 加载Dll,与初始化
  1. ThirdParty 第三方包 如: protobuf-net , Mongodb, NLog, kcp, Recast 等

### ET中的测试用例

游戏开发适合: 协议级别的单元测试

ET机器人的实现方式, 使用真实的客户端逻辑登录服务器, 通过使用GM修改机器人账号的数据 如:`set lv 100`

之后再按照对应协议测试相关逻辑

* 技巧
  1. 利用协程 `await`
  2. 利用消息事件回调
  3. 不要用时间卡逻辑 , 用协程 `await`

### Robot 机器人测试(压测)

用于针对整体业务逻辑做测试(压测), 或者匹配机器人等业务

### ConsoleComponent 命令行组件

命令行组件指令:

```c#
public static class ConsoleMode
{
    public const string ReloadDll = "R";
    public const string ReloadConfig = "C";
    public const string ShowMemory = "M";
    public const string Repl = "Repl";
    public const string Debugger = "Debugger";
    public const string CreateRobot = "CreateRobot"; //CreateRobotConsoleHandler
    public const string Robot = "Robot"; //RobotConsoleHandler
}
```

`ConsoleComponent.Start`

```c#
while (true)
{
  ModeContex modeContex = self.GetComponent<ModeContex>();
  //子集命令  如: Robot>
  string line = await Task.Factory.StartNew(() =>
  {
      Console.Write($"{modeContex?.Mode ?? ""}> ");
      return Console.In.ReadLine();//异步等待控制台输入
  }, self.CancellationTokenSource.Token);
  line = line.Trim();
  switch (line)
  {
      case "":
          break;
      case "exit":
          self.RemoveComponent<ModeContex>();
          break;
      default:
      {
          string[] lines = line.Split(" ");
          //解析命令模式
          string mode = modeContex == null? lines[0] : modeContex.Mode;
          if (!self.Handlers.TryGetValue(mode, out IConsoleHandler iConsoleHandler))
          {
              Log.Console($"not found command: {line}");
              break;
          }
          if (modeContex == null)
          {
              modeContex = self.AddComponent<ModeContex>();
              modeContex.Mode = mode;
          }
          await iConsoleHandler.Run(modeContex, line);
          break;
      }
  }
}
```

## RobotCase 测试用例

针对具体功能逻辑做协议测试

### 测试用例启动方式

依然使用启动参数 : `--Console=1`

1. 输入:`Robot`, 进入RobotCase模式
1. `Robot> Run 1`, 执行 1 号测试用例
1. `Robot> RunAll` 将执行所有测试用例

### RobotConsoleHandler

```c#
case "Run":
{
    int caseType = int.Parse(ss[1]);
    RobotLog.Debug($"run case start: {caseType}");
    //通过 EventSystem.Invoke 分发到指定 Case 执行逻辑
    await EventSystem.Instance.Invoke<RobotInvokeArgs, ETTask>(caseType, new RobotInvokeArgs() { Content = content });
    RobotLog.Debug($"run case finish: {caseType}");
    break;
}
case "RunAll":
{
    FieldInfo[] fieldInfos = typeof (RobotCaseType).GetFields();
    foreach (FieldInfo fieldInfo in fieldInfos)
    {
        int caseType = (int)fieldInfo.GetValue(null);
        if (caseType > RobotCaseType.MaxCaseType)
        {
            RobotLog.Debug($"case > {RobotCaseType.MaxCaseType}: {caseType}");
            break;
        }
        RobotLog.Debug($"run case start: {caseType}");        
        await EventSystem.Instance.Invoke<RobotInvokeArgs, ETTask>(caseType, new RobotInvokeArgs() { Content = content});
        RobotLog.Debug($"---------run case finish: {caseType}");
    }
    break;
}
```

### ARobotCase

类似 `ATimer` 定时器, 基于 `EventSystem.Invoke` 关联 `RobotCase` 的逻辑分发并执行

### RobotCase_FirstCase

创建多个 Robot 登录并进入场景, 并发送 `M2C_TestRobotCase` 协议

```c#
protected override async ETTask Run(RobotCase robotCase)
{
    Console.WriteLine($"Start FirstCase...");
    using ListComponent<Scene> robots = ListComponent<Scene>.Create();
    
    // 创建了两个机器人，生命周期是RobotCase，RobotCase_FirstCase.Run执行结束，机器人就会删除
    await robotCase.NewRobot(2, robots);
    using ListComponent<ETTask> robotsTasks = ListComponent<ETTask>.Create();
    robotsTasks.Add(robotCase.NewRobot(10, robots));
    await ETTaskHelper.WaitAll(robotsTasks);
    foreach (Scene robotScene in robots)
    {
        M2C_TestRobotCase response = await robotScene.GetComponent<Client.SessionComponent>().Session.Call(new C2M_TestRobotCase() {N = robotScene.Zone}) as M2C_TestRobotCase;
        if (response.N != robotScene.Zone)
        {
            // 跟预期不一致就抛异常，外层会catch住在控制台上打印
            throw new Exception($"robot case: {RobotCaseType.FirstCase} run fail!");
        }
    }
    Console.WriteLine($"FirstCase Finish.");
}
```

`RobotCase.NewRobot` 内部实现的是创建Client 连接, 登录并进入Map场景

```c#
clientScene = await Client.SceneFactory.CreateClientScene(zone, $"Robot_{zone}");
await Client.LoginHelper.Login(clientScene, zone.ToString(), zone.ToString());
await Client.EnterMapHelper.EnterMapAsync(clientScene);
```

### RobotCase_SecondCase

等待指定消息的返回, 再执行后续操作; 用于两个协议之间不是 RPC 关系串行操作

```c#
[MessageHandler(SceneType.Client)]
public class M2C_TestRobotCaseHandler:AMHandler<M2C_TestRobotCase2>
{
  protected override async ETTask Run(Session session, M2C_TestRobotCase2 message)
  {
    Log.Debug($"Robot SecondCase M2C_TestRobotCase");
    ObjectWait objectWait = session.ClientScene().GetComponent<ObjectWait>();
    objectWait?.Notify(new RobotCase_SecondCaseWait(){Error = WaitTypeError.Success,M2CTestRobotCase = message});
    await ETTask.CompletedTask;
  }
}

[Invoke(RobotCaseType.SecondCase)]
public class RobotCase_SecondCase: ARobotCase
{
  protected override async ETTask Run(RobotCase robotCase)
  {
    Scene      robotScene = await robotCase.NewRobot(1);
    ObjectWait objectWait = robotScene.GetComponent<ObjectWait>();
    robotScene.GetComponent<Client.SessionComponent>().Session.Send(new C2M_TestRobotCase2(){N = robotScene.Zone});
    RobotCase_SecondCaseWait robotCaseSecondCaseWait = await objectWait.Wait<RobotCase_SecondCaseWait>();
    if (robotCaseSecondCaseWait.M2CTestRobotCase.N != robotScene.Zone)
    {
      throw new Exception($"robot case:{RobotCaseType.SecondCase} run fail!");
    }
    ClientSceneManagerComponent.Instance.Remove((int)robotScene.Id);//测试完毕回收资源
  }
}
```

* 相关协议

```pb
message C2M_TestRobotCase2 // IActorLocationMessage
{
 int32 RpcId = 1;
 int32 N = 2;
}

message M2C_TestRobotCase2 // IActorMessage
{
 int32 N = 2;
}

message C2M_OfflineUnit // IActorLocationMessage
{
 int32 RpcId = 1;
}
```

### ObjectWait

用于保证代码串行化

## 机器人启动方式

服务器启动参数添加 : `--Console=1` 添加 `ConsoleComponent` 命令行组件

<img src="../img/ET7_Robot_1.png" width="60%"/>

创建两个机器人, 在命令行输入指令: `CreateRobot --Num=2`

### CreateRobotConsoleHandler 解析指令参数

解析指令参数并创建对应Robot

服务器启动时已经将 RobotScene 添加到 Root(根Scene) `RootScene SceneFactory.CreateServerScene -> EntitySceneFactory.CreateScene`

```c#
CreateRobotArgs options = null;
Parser.Default.ParseArguments<CreateRobotArgs>(content.Split(' '))
        .WithNotParsed(error => throw new Exception($"CreateRobotArgs error!"))
        .WithParsed(o => { options = o; });
// 获取当前进程的RobotScene
using (ListComponent<StartSceneConfig> thisProcessRobotScenes = ListComponent<StartSceneConfig>.Create())
{   //配置中的 Robot Scene
    List<StartSceneConfig> robotSceneConfigs = StartSceneConfigCategory.Instance.Robots;
    foreach (StartSceneConfig robotSceneConfig in robotSceneConfigs)
    {
        if (robotSceneConfig.Process != Options.Instance.Process)
        {
            continue;
        }
        thisProcessRobotScenes.Add(robotSceneConfig);
    }
    // 创建机器人
    for (int i = 0; i < options.Num; ++i)
    {
        int index = i % thisProcessRobotScenes.Count;
        StartSceneConfig robotSceneConfig = thisProcessRobotScenes[index];
        //服务器启动时已经将 RobotScene 添加到 RootScene SceneFactory.CreateServerScene -> EntitySceneFactory.CreateScene
        Scene robotScene = ServerSceneManagerComponent.Instance.Get(robotSceneConfig.Id);
        RobotManagerComponent robotManagerComponent = robotScene.GetComponent<RobotManagerComponent>();
        //RobotManagerComponent 执行机器人登录, 进入场景逻辑
        Scene robot = await robotManagerComponent.NewRobot(Options.Instance.Process * 10000 + i);
        robot.AddComponent<AIComponent, int>(1);//添加 AI 组件
        Log.Console($"create robot {robot.Zone}");
        await TimerComponent.Instance.WaitAsync(2000);
    }
}
```

### RobotManagerComponent 创建 Robot ClientScene

发送登录, 进入场景等协议; 实际应用中可以添加GM指令填充机器人属性

ET Demo 这里是将机器人逻辑都放在 `RobotManagerComponent` 里面

如果需要登录大量的 Robot 可以将这部分逻辑移植到独立的 `RobotAgent` 节点中(可以配置部署多个), 从而提高机器人部署数量

```c#
public static async ETTask<Scene> NewRobot(this RobotManagerComponent self, int zone)
{
    Scene clientScene = null;
    clientScene = await Client.SceneFactory.CreateClientScene(zone, "Robot");
    await Client.LoginHelper.Login(clientScene, zone.ToString(), zone.ToString());
    await Client.EnterMapHelper.EnterMapAsync(clientScene);
    Log.Debug($"create robot ok: {zone}");
    return clientScene;
}
```