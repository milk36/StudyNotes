# dotnet编码笔记

## .Net虚拟机

### IL / CIL 是什么？

* Intermediate Language （IL）微软中间语言

* 通用中间语言（Common Intermediate Language，简称CIL，发音为"sill"或"kill"）是一种属于通用语言架构和.NET框架的低阶（lowest-level）的人类可读的编程语言。目标为.NET框架的语言被编译成CIL，然后汇编成字节码。CIL类似一个面向对象的组合语言，并且它是完全基于堆栈的。它运行在虚拟机上，其主要的语言有C#、Visual Basic .NET(VB.NET)、C++/CLI以及J#。

## preprocessor 预处理

```c#
  public static void run()
  {
#if MILK
    Console.WriteLine("预处理!");
#else
    Console.WriteLine("无预处理");
#endif

    #region Test region 可以使用以下两个预处理器指令来定义可在大纲中折叠的代码区域：

    Console.WriteLine("test region");

    #endregion
  }
```

### [定义区域](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/preprocessor-directives#defining-regions)

利用 `#region`，可以指定在使用代码编辑器的大纲功能时可展开或折叠的代码块。 在较长的代码文件中，折叠或隐藏一个或多个区域十分便利，这样，可将精力集中于当前处理的文件部分。

* `#region` :启动区域。
* `#endregion` :结束区域。

## 关键字

### where (泛型类型约束)

例如，可以声明一个泛型类 AGenericClass，以使类型参数 T 实现 IComparable<T> 接口:

```C#
public class AGenericClass<T> where T : IComparable<T> { }
```

### [delegate (委托)](https://learn.microsoft.com/zh-cn/dotnet/csharp/programming-guide/delegates/)

lambda 表达式只是指定委托的另一种方式

```C#
  public static void run()
  {
    //匿名函数写法 Action无返回值
    Action<int,string> fun1= delegate(int i, string s)
    {
      Console.WriteLine($"int value:{i} string value:{s} ");
    };
    //有返回值
    Func<int,string,string> fun2 = delegate(int i, string s)
    {
      return i + s;
    };
    //lambda表达式
    Action<int,string> fun3= (i, s) =>
    {
      Console.WriteLine($"int value:{i} string value:{s} ");
    };
    
    Func<int,string,string> fun4 = (i, s) =>
    {
      return i + s;
    };
    
    Fun0 f0 = showMsg;
    f0("hi delegate");

    fun1(12, "yoyo");
    Console.WriteLine(fun2(222, "kkk"));
    fun3(22, "delegate");
    Console.WriteLine(fun4(333, "jjj"));
  }
  //传统delegate方式
  public delegate void Fun0(string msg);

  public static void showMsg(string msg)
  {
    Console.WriteLine($"input:{msg}");
  }
```

* [委托与加减运算符](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/addition-operator#delegate-combination)

  ```c#
  private static Action _action;
  
  public static void Run()
  {
    _action = () => doUpdate();
    _action += doLastUpdate;
    _action();
  }

  private static int doUpdate()
  {
    Console.WriteLine("do update");
    return 1;
  }

  private static void doLastUpdate()
  {
    Console.WriteLine("do last update");
  }
  //输出
  //do update
  //do last update
  ```

### [get / set 访问器](https://learn.microsoft.com/zh-cn/dotnet/csharp/programming-guide/classes-and-structs/using-properties)

```c#
public class Date
{
    private int _month = 7;  // Backing store

    public int Month
    {
        get => _month;
        set
        {
            if ((value > 0) && (value < 13))
            {
                _month = value;
            }
        }
    }
}
```

### [out 参数修饰符](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/out-parameter-modifier)

`out` 关键字通过引用传递参数。 它让形参成为实参的别名，这必须是变量。 换而言之，对形参执行的任何操作都是对实参执行的

```c#
public static void Run()
  {
    int num = 312;
    string message = "yoyo",msg = "kkk";
    Method(out num,out message,msg); //调用具有out参数的方法
    Console.WriteLine($"num:{num} message:{message} msg:{msg}");
  }
  //声明out参数
  private static void Method(out int answer, out string message, string msg)
  {
    answer = 7788;
    message = "testMsg";
    msg = "test";
  }
```

### partial

通过分部类型可以定义要**拆分到多个文件**中的类、结构、接口或记录

### virtual 虚函数

在Java中，所有函数默认都是virtual(虚函数)的，

而在C#中所有函数并不默认为virtual的，但可以在基类中通过声明关键字virtual，就可以在其派生类中通过关键字override重写该函数。

即只有申明了virtual的函数才能在子类中重载,否则依然调用的是父类函数

```c#
class Program
{
    static void Main(string[] args)
    {
        A a1 = new A(); a1.Print();
        A a2 = new B(); a2.Print();
        A a3 = new C(); a3.Print();
        Console.Read();
    }
}
class A
{
    public virtual void Print()
    {
        Console.WriteLine("A");
    }
}
class B : A
{
    public override void Print()
    {
        Console.WriteLine("B");
    }
}
class C : B
{
    public void Print() //此处没有override关键字,无法重写
    {
        Console.WriteLine("C");
    }
}
// 输出结果:A
//         B 
//         B
```

## 运算符表达式

### `?. 和 ?[]` [Null 条件运算符](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/member-access-operators#null-conditional-operators--and-)

仅当操作数的计算 **结果为非 NULL 时**，NULL 条件运算符 **才对其操作数应用成员访问 ?. 或元素访问?[] 操作**；否则，它会返回 null。

`var result = obj?.GetXXX();` 类似这样的调用: `var result = obj != null ? obj.GetXXX() : Null;`

```c#
object test =null;
Console.WriteLine($"result:{test?.ToString()}");
test = new object();
Console.WriteLine($"result:{test?.ToString()}");
int[] arr = null;
Console.WriteLine($"arr length:{arr?.Length} first:{arr?[0]}");
arr = new int[10];
Console.WriteLine($"arr length:{arr?.Length} first:{arr?[0]}");

/*输出结果
result:
result:System.Object
arr length: first:
arr length:10 first:0
*/
```

## 静态扩展方法

扩展方法使你能够向现有类型“添加”方法，而无需创建新的派生类型、重新编译或以其他方式修改原始类型。 扩展方法是一种静态方法，但可以像扩展类型上的实例方法一样进行调用

```c#
public static class StaticExtensionMeth
{
  public static int AddExtensionMethod(this ExtensionTarget self,int i) //向ExtensionTarget类型上添加AddExtensionMethod方法
  {
    Console.WriteLine($"input:{i} name:{self.Name}");
    return i + 100;
  }

  public static void run()
  {
    ExtensionTarget target = new ExtensionTarget();
    target.Name = "Test Extension Method";
    Console.WriteLine($"output:{target.AddExtensionMethod(999)}");
  }
}
public class ExtensionTarget
{
  private string name;
  public string Name
  {
    get ;
    set ;
  }
}
```

## [await / async 异步编程](https://learn.microsoft.com/zh-cn/dotnet/csharp/programming-guide/concepts/async/)

> 异步非并行(并非一定是多线程执行)

异步编程主要针对两种场景使用: I/O操作, CPU密集型操作

* 避免使用: `Thread.Sleep(1000)` 而使用 `await Task.Delay(1000)` 替换
* [.NET 中什么样的类是可使用 await 异步等待的](https://blog.walterlv.com/post/what-is-an-awaiter)

  ```c#
  await DoAsync();

  private A DoAsync()
  {
      return new A();
  }

  public class A{}

  public static class AExtenstions
  {
      public static DiyAwaiter GetAwaiter(this A a)
      {
          return new DiyAwaiter();
      }
  }
  //Awaiter 对象
  public class DiyAwaiter : INotifyCompletion
  {
      public bool IsCompleted { get; }
      public void GetResult() { }
      public void OnCompleted(Action continuation) { }
  }
  ```
  总结起来，要想使一个方法可被 await 等待，必须具备以下条件：

  1. 这个方法返回一个类 A 的实例，这个类 A 必须满足后面的条件。
  1. 此类 A 有一个可被访问到的 GetAwaiter 方法（扩展方法也行），方法返回类 Awaiter 的实例，这个类 Awaiter 必须满足后面的条件；
  1. 其中有一个GetAwaiter()方法，该方法返回一个awaiter。那什么是awaiter对象呢？满足如下3点条件即可：
     * 实现INotifyCompletion或ICriticalNotifyCompletion接口 `OnCompleted`
     * 有bool类型的IsCompleted属性
     * 有一个GetResult()来返回结果，或是返回void
  
## [特性](https://learn.microsoft.com/zh-cn/dotnet/csharp/programming-guide/concepts/attributes/)

特性，可以有效地将元数据或声明性信息与代码（程序集、类型、方法、属性等）相关联。 将特性与程序实体相关联后，可以在运行时使用反射这项技术查询特性。 

## [语言集成查询 (LINQ)](https://learn.microsoft.com/zh-cn/dotnet/csharp/programming-guide/concepts/linq/)

## GC调优

* [runtimeconfig.json 配置文件](https://learn.microsoft.com/zh-cn/dotnet/core/runtime-config/#runtimeconfigjson)
  
  构建项目时，将在输出目录中生成 [appname].runtimeconfig.json 文件。 如果项目文件所在的文件夹中存在 runtimeconfig.template.json 文件，它包含的任何配置选项都将插入到 [appname].runtimeconfig.json 文件中。
* [用于垃圾回收的运行时配置选项](https://learn.microsoft.com/zh-cn/dotnet/core/runtime-config/garbage-collector)
* [调试 .NET Core 中的内存泄漏](https://learn.microsoft.com/zh-cn/dotnet/core/diagnostics/debug-memory-leak)
* [分析.net core在linux下内存占用过高问题](https://www.cnblogs.com/zhenglisai/p/14751677.html)
* [.net 相关分析工具](https://www.yuque.com/et-xd/docs/ikuilq#ExIo0)

## dotnet

[.NET 命令行接口 (CLI)](https://learn.microsoft.com/zh-cn/dotnet/core/tools/) 工具是用于开发、生成、运行和发布 .NET 应用程序的跨平台工具链。

* 在 .NET Core 中，可以通过 --configuration 参数来设置启动时的环境变量。例如，以下命令将应用程序的最大内存限制设置为 2 GB：

  ```sh
  dotnet run --configuration "System.GC.Server=1" "System.GC.Concurrent=1" "System.GC.AllowVeryLargeObjects=1" "COMPlus_GCHeapHardLimit=2147483648"
  ```

  其中，"COMPlus_GCHeapHardLimit=2147483648" 将最大堆大小设置为 2 GB。"System.GC.Server=1" 和 "System.GC.Concurrent=1" 设置了垃圾收集器的模式，而 "System.GC.AllowVeryLargeObjects=1" 则允许分配非常大的对象。

  请注意，这些参数的具体含义和用法可能因 .NET Core 版本而异。你应该查阅相应的文档以获取更详细的信息。

* [.NET Core 中提供哪些诊断工具](https://learn.microsoft.com/zh-cn/dotnet/core/diagnostics/)
* [Netsh http 命令](https://learn.microsoft.com/zh-cn/windows-server/networking/technologies/netsh/netsh-http)