# dotnet编码笔记

## 关键字

### where (泛型类型约束)

例如，可以声明一个泛型类 AGenericClass，以使类型参数 T 实现 IComparable<T> 接口:

```C#
public class AGenericClass<T> where T : IComparable<T> { }
```

### [delegate (委托)](https://learn.microsoft.com/zh-cn/dotnet/csharp/programming-guide/delegates/)

lambda 表达式只是指定委托的另一种方式

```C#
  public static void run()
  {
    //匿名函数写法 Action无返回值
    Action<int,string> fun1= delegate(int i, string s)
    {
      Console.WriteLine($"int value:{i} string value:{s} ");
    };
    //有返回值
    Func<int,string,string> fun2 = delegate(int i, string s)
    {
      return i + s;
    };
    //lambda表达式
    Action<int,string> fun3= (i, s) =>
    {
      Console.WriteLine($"int value:{i} string value:{s} ");
    };
    
    Func<int,string,string> fun4 = (i, s) =>
    {
      return i + s;
    };
    
    Fun0 f0 = showMsg;
    f0("hi delegate");

    fun1(12, "yoyo");
    Console.WriteLine(fun2(222, "kkk"));
    fun3(22, "delegate");
    Console.WriteLine(fun4(333, "jjj"));
  }
  //传统delegate方式
  public delegate void Fun0(string msg);

  public static void showMsg(string msg)
  {
    Console.WriteLine($"input:{msg}");
  }
```

### [get / set 访问器](https://learn.microsoft.com/zh-cn/dotnet/csharp/programming-guide/classes-and-structs/using-properties)

```c#
public class Date
{
    private int _month = 7;  // Backing store

    public int Month
    {
        get => _month;
        set
        {
            if ((value > 0) && (value < 13))
            {
                _month = value;
            }
        }
    }
}
```

### [out 参数修饰符](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/out-parameter-modifier)

`out` 关键字通过引用传递参数。 它让形参成为实参的别名，这必须是变量。 换而言之，对形参执行的任何操作都是对实参执行的

```c#
public static void Run()
  {
    int num = 312;
    string message = "yoyo",msg = "kkk";
    Method(out num,out message,msg); //调用具有out参数的方法
    Console.WriteLine($"num:{num} message:{message} msg:{msg}");
  }
  //声明out参数
  private static void Method(out int answer, out string message, string msg)
  {
    answer = 7788;
    message = "testMsg";
    msg = "test";
  }
```

### partial

通过分部类型可以定义要**拆分到多个文件**中的类、结构、接口或记录

### virtual 虚函数

在Java中，所有函数默认都是virtual(虚函数)的，

而在C#中所有函数并不默认为virtual的，但可以在基类中通过声明关键字virtual，就可以在其派生类中通过关键字override重写该函数。

即只有申明了virtual的函数才能在子类中重载,否则依然调用的是父类函数

```c#
class Program
{
    static void Main(string[] args)
    {
        A a1 = new A(); a1.Print();
        A a2 = new B(); a2.Print();
        A a3 = new C(); a3.Print();
        Console.Read();
    }
}
class A
{
    public virtual void Print()
    {
        Console.WriteLine("A");
    }
}
class B : A
{
    public override void Print()
    {
        Console.WriteLine("B");
    }
}
class C : B
{
    public void Print() //此处没有override关键字,无法重写
    {
        Console.WriteLine("C");
    }
}
// 输出结果:A
//         B 
//         B
```

## 运算符表达式

### `?. 和 ?[]` Null 条件运算符

仅当操作数的计算 **结果为非 NULL 时**，NULL 条件运算符 **才对其操作数应用成员访问 ?. 或元素访问?[] 操作**；否则，它会返回 null。

```c#
object test =null;
Console.WriteLine($"result:{test?.ToString()}");
test = new object();
Console.WriteLine($"result:{test?.ToString()}");
int[] arr = null;
Console.WriteLine($"arr length:{arr?.Length} first:{arr?[0]}");
arr = new int[10];
Console.WriteLine($"arr length:{arr?.Length} first:{arr?[0]}");

/*输出结果
result:
result:System.Object
arr length: first:
arr length:10 first:0
*/
```

## 静态扩展方法

扩展方法使你能够向现有类型“添加”方法，而无需创建新的派生类型、重新编译或以其他方式修改原始类型。 扩展方法是一种静态方法，但可以像扩展类型上的实例方法一样进行调用

```c#
public static class StaticExtensionMeth
{
  public static int AddExtensionMethod(this ExtensionTarget self,int i) //向ExtensionTarget类型上添加AddExtensionMethod方法
  {
    Console.WriteLine($"input:{i} name:{self.Name}");
    return i + 100;
  }

  public static void run()
  {
    ExtensionTarget target = new ExtensionTarget();
    target.Name = "Test Extension Method";
    Console.WriteLine($"output:{target.AddExtensionMethod(999)}");
  }
}
public class ExtensionTarget
{
  private string name;
  public string Name
  {
    get ;
    set ;
  }
}
```

## [await / async 异步编程](https://learn.microsoft.com/zh-cn/dotnet/csharp/programming-guide/concepts/async/)

> 异步非并行(并非一定是多线程执行)

异步编程主要针对两种场景使用: I/O操作, CPU密集型操作

* 避免使用: `Thread.Sleep(1000)` 而使用 `await Task.Delay(1000)` 替换

## [特性](https://learn.microsoft.com/zh-cn/dotnet/csharp/programming-guide/concepts/attributes/)

特性，可以有效地将元数据或声明性信息与代码（程序集、类型、方法、属性等）相关联。 将特性与程序实体相关联后，可以在运行时使用反射这项技术查询特性。

## [语言集成查询 (LINQ)](https://learn.microsoft.com/zh-cn/dotnet/csharp/programming-guide/concepts/linq/)

## GC调优

* [用于垃圾回收的运行时配置选项](https://learn.microsoft.com/zh-cn/dotnet/core/runtime-config/garbage-collector)